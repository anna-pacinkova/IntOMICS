% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/BN_module_func.R
\name{squared_jumping}
\alias{squared_jumping}
\title{Squared jumping of adaptive MCMC algorithm}
\usage{
squared_jumping(
  second.adapt.phase_net,
  constant,
  fin,
  beta_sd,
  B_prior_mat,
  omics,
  parent_set_combinations,
  BGe_score_all_configs_node,
  layers_def,
  prob_mbr,
  annot
)
}
\arguments{
\item{second.adapt.phase_net}{list output of the variance_target
or squared_jumping function.}

\item{constant}{numeric vector used to multiply the beta_sd to determine
the variance of the distribution of the hyperparameter beta.}

\item{fin}{numeric vector iteration to stop.}

\item{beta_sd}{numeric vector used to determine the variance
of the distribution of the hyperparameter beta.}

\item{B_prior_mat}{a biological prior matrix.}

\item{omics}{named list containing the gene expression (possibly copy number
variation and methylation data).
Each component of the list is a matrix with samples in rows and
features in columns.}

\item{parent_set_combinations}{list of all possible parent set configuration
for all nodes available.}

\item{BGe_score_all_configs_node}{list of nodes BGe score for all possible
parent set configurations.}

\item{layers_def}{data.frame containing the modality ID, corresponding layer
in BN and maximal number of parents from given layer to GE nodes.}

\item{prob_mbr}{numeric vector probability of the MBR step.}

\item{annot}{named list containing the associated methylation probes of
given gene.}
}
\value{
List of 1 element: second adaptive phase result with stopped
MCMC mixing
}
\description{
\code{squared_jumping} Squared jumping of adaptive MCMC algorithm is used to tune
the variance of the beta parameter.
}
\examples{
data(list=c("OMICS_mod_res", "first.adapt.phase_net", "annot"), 
package="IntOMICS")
if(interactive()){transient.phase_net <- transient_phase(prob_mbr = 0.07,
first.adapt.phase_net = first.adapt.phase_net, 
omics = OMICS_mod_res$omics, B_prior_mat = OMICS_mod_res$B_prior_mat, 
layers_def = OMICS_mod_res$layers_def, annot = OMICS_mod_res$annot,
energy_all_configs_node = 
OMICS_mod_res$pf_UB_BGe_pre$energy_all_configs_node,
BGe_score_all_configs_node = 
OMICS_mod_res$pf_UB_BGe_pre$BGe_score_all_configs_node, 
parent_set_combinations = 
OMICS_mod_res$pf_UB_BGe_pre$parents_set_combinations) 
second_adapt_phase_net <- second_adapt_phase(prob_mbr = 0.07, 
transient.phase_net = transient.phase_net, woPKGE_belief = 0.5,
layers_def = OMICS_mod_res$layers_def, annot = OMICS_mod_res$annot,
energy_all_configs_node = 
OMICS_mod_res$pf_UB_BGe_pre$energy_all_configs_node, 
B_prior_mat = OMICS_mod_res$B_prior_mat, 
BGe_score_all_configs_node = 
OMICS_mod_res$pf_UB_BGe_pre$BGe_score_all_configs_node, 
parent_set_combinations = 
OMICS_mod_res$pf_UB_BGe_pre$parents_set_combinations,
omics = OMICS_mod_res$omics)
squared_jumping(omics = OMICS_mod_res$omics,
second.adapt.phase_net = second.adapt.phase_net$variance.target_net, 
constant = 2.38/(1.5), fin = (nrow(OMICS_mod_res$B_prior_mat)^2)*5, 
beta_sd = second.adapt.phase_net$beta_sd, prob_mbr = 0.07,
B_prior_mat = OMICS_mod_res$B_prior_mat, 
layers_def = OMICS_mod_res$layers_def,
parent_set_combinations=OMICS_mod_res$pf_UB_BGe_pre$parents_set_combinations,
BGe_score_all_configs_node=OMICS_mod_res$pf_UB_BGe_pre$BGe_score_all_configs_node,
annot = annot)}

}
